# Типы данных класса "Функтор" (Functor)

К классу `Functor` относятся любые типы данных второго подрядка (ещё называемые "Конструкторами типов"), kind `Type -> Type`.

```purescript
forall f a. f a
```
(примеры: `List`, `Maybe`, `Either String`, `data MyPhantomType a = Empty`, `(->) a`)

для которых можно определить функцию `map` такого типа:

```purescript
class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b  
```

Если между любыми двумя типами `a` и `b` существует отношение `a -> b` а также есть любой тип `f` относящийся к классу функторов, то значит существует и отношение между типами `f a -> f b`, которое подчинаяется 
следующим законам:

1. Закон идентичности (Identity)
  ```purescript
  map identity = identity
  
  where
    identity :: forall a. a -> a
    identity a = a 
  ```

2. Закон композиции (Composition)

```purescript
map (g <<< f) = map g <<< map f 
```

> Когда говорят просто _Функтор_, то имеют ввиду "_Тип данных второго порядка, относящийся к классу Функтор_". Это ещё означает, что данного типа данных определена функция `map`

## Интуиция

Вот несколько конкретных примеров-метафор отражающих идею класса типов-функторов
и дающих интуицию для её понимания:

### Функтор как контейнер

в типe `f a`:
- переменная типа `f` означает тип контейнера.
- переменная типа `a` означает тип содержимого контейнера.

Допустим у нас определён такой тип
```purescript
data Container a = Container a
```

тогда в применении к этому типу функция `map` класса `Functor` 
определяется следующим образом:

```purescript
map :: forall a. (a -> b) -> (Container a -> Container b)
map ab (Container a) = 
--     ^^^^^^^^^^^^ разобрать контейнер, 
  let b = ab a
--    ^^^^^^^^ поменять а на b, 
  in Container b
--   ^^^^^^^^^^^ положить b в новый контейнер
```

и её можно использовать:

```purescript
box :: Container Int
box = Container 42

map (_ + 1) box == Container 43
```

| Название переменной типа  |     f     |  a  |
|---------------------------|-----------|-----|
| Название конкретного типа | Container | Int |

В данном примере переменной типа `f` соответствует тип `Container` 
храняший значение типа `Int`. 

### Функтор как вычисление

в типe `f a`:
- переменная типа `f` означает тип вычисления.
- переменная типа `a` означает тип результата.

`Transform String`

| Название переменной типа  |     f     |   a    |
|---------------------------|-----------|--------|
| Название конкретного типа | Transform | String |

Пример использования:

```purescript
-- | Объявление типа "Трансформация"
data Transform a 
  = Lowercase a 
  | Uppercase a 

-- | Создание вычисления-трансформации,
-- | соответствующей переводу символов в верхний регистр.
lowercase :: String -> Transform String
lowercase str = Lowercase str

-- | Создание вычисления-трансформации,
-- | соответствующей переводу символов в нижний регистр.
uppercase :: String -> Transform String
uppercase str = Uppercase str

-- | Интерпретация, т.е. собственно выполнение вычисления.
runTransform :: Transform String -> String
runTransform = case _ of
  Lowercase x -> strToLower x
  Uppercase x -> strToUpper x
```

### Функтор как изменение смысла

в типe `f a`:
- переменная типа `a` представляет некоторый тип данных.
- переменная типа `f` означает некоторое изменение смысла этих данных (эффект над смыслом)

`Maybe Boolean`, `List Boolean`

| Название переменной типа  |   f   |    a    |
|---------------------------|-------|---------|
| Название конкретного типа | Maybe | Boolean |
| Название конкретного типа | List  | Boolean |

Оригинальным смыслом типа `Boolean` является 
> выбор между `true` или `false`,

а изменённым смыслом (типом `Maybe Boolean`) является  

> _необязательный_ выбор между `true` или `false`

а в случае `List Boolean` это

> _многократный_ выбор между `true` или `false`

## Композиция Функторов

Т.к. функтор это тип данных, обладающий свойством `map`, то композиция (объединение) функторов
это ни что иное как уже знакомая нам композиция типов данных, результат которой, тоже обладает этим свойством.

Уже знакомые нам три способа композиции (объединения) типов данных:

1. __ВНУТРИ__
2. __И__
3. __ИЛИ__

Давайте рассмотрим композицию Функторов, каждым из этих способов по очереди.

Представим, что у нас уже есть два функтора, которые мы хотим объединить:

`forall f g. (Functor f, Functor g) =>`

> Оба этих функтора являются типами второго порядка, kind `Type -> Type`
  Если взять любой другой тип данных `forall a.` то применив к нему функторы `f` и `g` 
  мы получим типы первого порядка:
  - `f a`
  - `g a`


> Конкретными примерами `f` и `g` могут служить такие типы данных как
 `Array`, `List`, `Maybe`, ...

```purescript

-- ВНУТРИ
newtype Compose (f :: Type -> Type) (g :: Type -> Type) (a :: Type)
  = Compose (f (g a))

-- И (Product type)
data ComposeP (f :: Type -> Type) (g :: Type -> Type) (a :: Type)
  = ComposeP (f a) (g a)

-- ИЛИ (Sum type)
data ComposeS (f :: Type -> Type) (g :: Type -> Type) (a :: Type)
  = ComposeF (f a)
  | ComposeG (g a)

```
