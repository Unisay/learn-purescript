# Проблема эффектов в чистом ЯП

Мы начнём с очевидного фундаментального конфликта. "Чистая" функциональная программа является функцией; Она не имеет побочных эффектов. Однако неизменной целью запуска программы является побочный эффект, который она производит: изменение файла, какие-то новые пиксели на экране, отправленное сообщение и тп.
Ввод-вывод (I/O) это смысл существования каждой программы. Иначе говоря, программа, не имеющая никаких обозримых эффектов (нет ввода, нет вывода), для нас бесполезна.

Хорошо, если побочный эффект не может происходить внутри чистой функциональной программы, то он должен происходить за её пределами. Например, возможная функциональная программа является отношением входящей строки к выходящей:

```haskell
main :: String -> String
```

Допустим, что некоторая программа-обёртка написанная на C может получить строку откуда-то (из указанного файла, например, или из потока стандартного ввода), применить функцию к ней, записать строку-результат где-то (в другом файле или потоке стандартного вывода).

Таким образом, наши функциональные программы могут оставаться чистыми-невинными (свободными от побочных эффектов), а все грехи (побочные эффекты) будут находиться в программе-обёртке.

## Потоковый ввод/вывод (Streaming I/O)

Проблема в том, что один грех ведет к другому. Что если вы хотите считать более одного файла?
Или удалить файлы, открыть сетевые соединения-сокеты, задержать выполнение программы на указанное время, ...? Попробуем обогатить тип аргумента и тип результата нашей функции-программы:

```haskell
main :: List Response -> List Request
```

```
               ╔══════════════╗
 List Request  ║   Программа  ║  List Response
         ┌─────║              ║˂────────┐
         │     ║    (main)    ║         │
         │     ╚══════════════╝         │
         │     ╔════════════════════╗   │
         └────˃║    Обёртка         ║───┘
               ║ (Побочные эффекты) ║
               ╚════════════════════╝
```

Теперь наша программа принимает в качестве аргумента ленивый список (поток) значений типа `Response` и возвращает ленивый список (поток) значений типа `Request`.

Выражаясь неформально, `Request` говорит что-то вроде "Пожалуйста, дай мне содержимое того файла /etc/motd" а `Response` может говорить "Содержимое файла, которое ты запрашивал это No email today".

Более конкретно, и `Request` и `Response` являются обычными алгебраическими типами данных, что-то вроде этого:

```haskell
type FilePath = String

data Request = ReadFile FilePath
             | WriteFile FilePath String
             | ....

data Response = RequestFailed
              | ReadSucceeded String
              | WriteSucceeded
              | ...
```

Нам по-прежнему нужна программа-обёртка. Она берёт один `Request` за другим из потока результатов функции, выполняет соответствующий побочный эффект и добавляет `Response` к потоку аргументов функции.

Данный подход является достаточно выразительным и даже использовался как модель ввода/вывода в первой версии языка Haskell, но у него есть несколько недостатков:

- Его сложно расширять. Новые возможности ввода или вывода могут быть добавлены только с помощью расширения (добавления новых конструкторов) алгебраических типов `Request` и `Response`, а также изменением программы обёртки. Маловероятно, что обычные пользователи языка смогут это эффективно выполнять.

- Отсутствует близкое соответствие между запросом и соответствующим ему ответом. Становится очень легко написать программу в которой такое соответствие теряется по ошибке.

- Даже если на каждом шаге программы (при каждом вызове функции) такое соответствие и сохраняется, то всё равно очень легко по ошибке вычислить поток ответов на один дальше чем нужно и таким образом заблокировать выпуск дальнейших запросов в ожидании получения ответа на тот запрос, который уже не будет получен никогда.

Вместо того, чтоб пытаться исправить данные недостатки, мы перейдем к лучшему решению под названием "Монадический Ввод/Вывод" (monadic I/O).

## Монадический ввод/вывод (Monadic I/O)

Большй прорыв в моделировании ввода/вывода для чистых функциональных языков произошёл тогда, когда мы научились применять так называемые монады в качестве универсального способа структурирования функциональных программ. Ключевая идея заключается в следующем:

Значение типа `Effect a` преставляет собой некое "действие", во время выполнения которого могут происходить эффекты ввода/вывода, и результатом выполнения которого является значение типа `a`.

Это весьма абстрактрое объяснение, и я не буду удивлен если сейчас оно для вас почти ничего не означает. Поэтому вот ещё один, более конкретный взгляд на эти "действия":

```haskell
type Effect a = World -> Tuple a World
```

Это определение типа `Effect a` означает функцию, которая будучи применена к аргументу типа `World` возвращает новый `World` в паре с результатом типа `a`.

Эта идея ставит программу в центр: программа получает состояние целого мира в качестве входных данных (ввод) и возвращает новое состояние мира изменённое эффектами запуска программы в качестве результата.

Можно визуализировать значение типа `Effect a` так:

```
            ╔══════════╗
            ║          ║───> Результат: a
            ║ Effect a ║
World  ───˃ ║          ║───˃ World (изменённый)
            ╚══════════╝
```

Скармливая программе состояние мира слева, мы получаем новое состояние мира вместе с результатом типа `a` справа.

Вообще мы будем называть значение типа `Effect a` _"действием ввода/вывода"_ или просто _"действием"_. В литературе вы можете также встретить название _"вычисление"_.

Мы можем назначить типы `Effect` некоторым знакомым нам функциям, предоставляемым в качестве примитивов:

```haskell
getString :: Effect String
putString :: String -> Effect Unit
```

`getString` это такое действие ввода/вывода, которое при выполнении считывает строку из стандартного устройства ввода (таким образом оказывая эффект на мир, окружающий программу) и возвращает её программе в качестве результата действия.

`putString` это функция, которая принимает строку в качестве аргумента и возвращает действие ввода/вывода, которое при выполнении печатает строку на стандартном устройстве вывода (это его эффект оказываемый на окружающий мир) и возвращает программе тривиальное значение типа `Unit`.

Графически эти действия выглядят так: (the box for putString takes an extra input for the Char argument):

```
getString :: Effect String

      ╔═══════════╗ String
      ║           ║─────>
      ║ getString ║
 ────>║           ║─────>
      ╚═══════════╝

```

```
putString :: String -> Effect Unit

String ╔═══════════╗ Unit
 ─────>║           ║────>
       ║ putString ║
 ─────>║           ║────>
       ╚═══════════╝
```

Допустим, что мы хотим считать строку и напечатать строку, которую считали. Мы должны объеденить вместе два действия в одно (объединённое действие). Это можно представить так:

```
bind getString putString
╔═════════════════════════════════════════════════╗
║     ╔═══════════╗  String    ╔═══════════╗ Unit ║
║     ║           ║───────────>║           ║────> ║
║     ║ getString ║            ║ putString ║      ║
║ ───>║           ║───────────>║           ║────> ║
║     ╚═══════════╝            ╚═══════════╝      ║
╚═════════════════════════════════════════════════╝
```

Чтоб достигнуть этого объединения мы используем функцию-склейку, или функцию-комбинатор,
которая тоже предоставляется как примитив:

```haskell
bind :: forall a b. Effect a -> (a -> Effect b) -> Effect b

infixl 1 bind as >>=
```

```haskell
echo :: Effect Unit
echo = getString >>= putString
```

В своей инфиксной нотации этот комбинатор `>>=` часто произносится как "байнд" (связка). Он воплощает последовательную композицию действий: передаёт результат выполнения первого действия в качестве аргумента функции возвращающей второе действие.

А точнее, при выполнении объединённого действия `a >>= f`, он выполняет действие `a`, берёт его результат, применяет функцию `f` к нему чтобы получить новое действие, затем выполняет это новое действие.

В примере с функцией `echo` (`getString >>= putString`) сперва он выполняет `getString`, возвращающее строку `s`, и затем выполняет `putString s`.

Допустим, что мы хотим выполнить `echo` дважды подряд. Мы не можем использовать выражение `echo >>= echo`, так как оператор `>>=` ожидает во втором аргументе функцию а не действие ввода/вывода. И в самом деле, мы хотим отбросить результат типа `Unit` от первого действия. Будет удобно определить второй комбинатор `>>` c помощью уже имеющегося `>>=`:

```haskell
followedBy :: Effect a -> Effect b -> Effect b
followedBy ea eb = ea >>= \_ -> eb

infixl 1 followedBy as >>
```

Теперь мы можем написать

```haskell
echoTwice :: Effect Unit
echoTwice = echo >> echo
```

Оператор-комбинатор `>>` читается как "followedBy" ("следует за"), так что правая часть выражения читается как “echo followed by echo”.

На практике очень часто с правой стороны от оператора `bind` (`>>=`) находится лямбда абстракция (анонимная функция). Например, вот как мы можем считать строку и напечатать её дважды:

```haskell
echoDup :: Effect Unit
echoDup = getString >>= (\s -> (putString s >> putString s))
```

В этом примере все скобки не являются обязательными, т.к. лямбда распространяется слева направо, от косой черты и до самого конца строки, и вы часто можете встретить такое форматирование:

```haskell
echoDup :: Effect Unit
echoDup = getString   >>= \s ->
          putString s >>
          putString s
```

_Тот факт, что это выглядит похожим на последовательность команд в императивном языке программирования это не совпадение — это именно то, что мы пытаемся смоделировать._

Как можно написать действие ввода/вывода, которое считывает две строки и возвращает их обе в качестве результата?

Мы можем попытаться начать так:

```haskell
getTwoStrings :: Effect (Tuple String String)
getTwoStrings = getString >>= \s1 ->
                getString >>= \s2 ->
                ?whatGoesHere
```

Но какое выражение мы можем написать вместо `?whatGoesHere`?  
Оно должно иметь тип `Effect (Tuple String String)`, но мы уже выполнили все необходимые действия ввода/вывода!
То, что нам нужно, это ещё один комбинатор:

```haskell
pure :: a -> Effect a
```

Действие `pure a` на самом деле не совершает никакого ввода или вывода а мгновенно возвращает результат без каких-либо побочных эффектов. Мы можем отобразить его схематически следующим образом:

```
  a  ╔══════╗  a
 ───>║      ║───>
     ║ pure ║
 ───>║      ║───>
     ╚══════╝
```

Теперь мы легко можем завершить `getTwoStrings`:

```haskell
getTwoStrings :: Effect (Tuple String String)
getTwoStrings = getString >>= \s1 ->
                getString >>= \s2 ->
                pure (Tuple s1 s2)
```

А вот более реалистичный пример действия считывающего строки в массив,
пока не встретится строка `"."`:

```haskell
getLines :: Effect (Array String)
getLines =
  getString >>= \line ->
    if line == "." then pure []
    else
     getLines >>= \lines -> pure (line : lines)
```

В этом примере, `[]` это способ записи пустого массива в PureScript a `:`
это инфиксный вариант функции `Data.Array.cons`

Полная программа на языке PureScript является одним большим действием
ввода/вывода под названием `main`, и имеет тип `Effect Unit`.
Запуск программы прводит к выполнению этого действия.

Вот пример программы считывающей строку с устройства ввода (терминала),
инвертирующей её и печатающей результат на устройство вывода (экран):

```haskell
import Prelude
import Effect (Effect)
import Data.String (reverse)

main :: Effect Unit
main = getString >>= \str ->    -- 1
       putString (reverse str)  -- 2
```

Обратите внимание, что единственной операцией комбинирующей (или выполняющей композицию) действия ввода/вывода
является `>>=` и она трактует мир как однопоточный (в котором происходит только одно изменение в один момент времени).
Т.е. она берёт состояние мира полученное после первого действия и применяет к нему второе действие.
